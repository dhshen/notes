# Docker入门与实战

## 第一章：初识Docker

Docker是基于Go语言实现的开源容器项目。（dotCloud公司2013年）

Docker的构想：“Build,Ship and Run Any App,Anywhere”	“一次封装，到处运行”。

Docker的基础：Linux容器技术。(Linux  Container，LXC)

可以将Docker理解成一种轻量级的沙盒(sandBox)。每个容器内运行着一个应用，不同的容器相互隔离，容器之间可以通过网络互相通信。容器对系统资源的需求也十分有限，可以把容器理解成应用本身也没有问题。

如何正确的构建应用。

在云时代，开发者创建的应用必须要能方便的在网络上传播，也就是说必须脱离底层物理硬件的限制；同时必须是“任何时间、任何地点”可获取的。

通过容器打包应用，解耦应用和运行平台。

开发和运维(DevOps)

优势：

* 更快的交付和部署。
* 更高效的利用资源。它是内核级的虚拟化。
* 更轻松的迁移和扩展。
* 更简单的更新管理。



与传统虚拟机的比较：

* 快。启动和停止可以在秒级实现。
* 资源需求少，一台主机上可运行数千个Docker容器。除了运行其中的应用外，基本不消耗额外的系统资源。
* 通过类似Git设计理念的操作来方便用户获取、分发和更新应用镜像，存储复用，增量更新。
* 通过Dockerfile支持灵活的自动化创建和部署机制。



## 第二章：核心概念与安装配置

三大核心概念：镜像、容器、仓库。

**镜像**：类似于虚拟机镜像，可以将它理解为一个只读的模板。

例如：一个镜像可以包含一个基本的操作系统环境，里面仅安装了Apache应用程序。可以把它称为一个Apache镜像。

镜像是创建Docker容器的基础。



**容器**：类似于一个轻量级的沙箱。Docker利用容器来运行和隔离应用。

**容器是从镜像创建的应用运行实例**

可以把容器看作是一个简易版的Linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子。

注意：**镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层**。



**仓库**：类似于代码仓库，它是Docker集中存放镜像文件的场所。

Docker仓库分为 **公开仓库**和**私有仓库**两种。

Docker Hub是最大的公开仓库。

Docker也支持用户在本地网络内创建一个只能自己访问的私有仓库。



### 安装Docker

Centos：

>To install Docker, you need the 64-bit version of CentOS 7.

[Docker官网的Centos安装指南](https://docs.docker.com/engine/installation/linux/centos/#/prerequisites)



## 第三章：使用Docker镜像

Docker运行容器前需要本地存在对应的镜像，如果镜像没有保存在本地，Docker会尝试先从默认镜像仓库下载。（默认使用Docker Hub公共注册服务器中的仓库，用户也可以通过配置，使用自定义的镜像仓库。）

通常情况下，描述一个镜像需要包括 **“名称+标签”** 信息。

可以使用docker pull命令直接从Docker Hub镜像源来下载镜像。

```Bash
docker pull IMAGE[:TAG]
```

对于Docker镜像来说，如果不显示指定TAG，则默认会选择`latest`标签，这会下载仓库中最新版本的镜像。

*注意：一般来说，latest标签意味着该镜像的内容会跟踪最新的非稳定版本而发布，内容是不稳定的。*

镜像文件由若干层（layer）组成。当不同的镜像包括相同的层时，本地仅存储该层的一份内容，减小了需要的存储空间。







